package day03;

public class TestBitMove {
    public static void main(String[] args) {
        System.out.println(3 << 2);
        /*
        3的二进制：00000000 00000000 00000000 00000011
        3<<2     00000000 00000000 00000000 00001100

        把结果 00000000 00000000 00000000 00001100粘贴到计算器中，就可以看十进制值是12

        快速计算方式：左移几位相当于乘以2的几次方
        3 << 2   等价于 3 * 2的2次 = 3 * 4 = 12
         */

        System.out.println(5 << 4);
        // 5 * 2的4次 = 5 * 16 = 80


        System.out.println(13 >> 2);
        /*
        快速计算方式：右移几位相当于除以2的几次方
        13 / 2的2次 = 13 / 4 = 3.xxxx 向下取整的过程 = 3

        13：  00000000 00000000 00000000 00001101
        13>>2： 00000000 00000000 00000000 00000011

         */

        System.out.println(-13 >> 2);
        /*
        快速计算方式：右移几位相当于除以2的几次方
        -13 / 2的2次 = -13 / 4 = -3.xxxx 向下取整的过程 = -4
        -13的二进制补码：11111111 11111111 11111111 11110011
        -13>>2        11111111 11111111 11111111 11111100
        最高位是1，仍然是负数
        同样把 11111111 11111111 11111111 11111100补码结果粘到计算器中

        如果要人工算，需要换为原码
            11111111 11111111 11111111 11111100 补码
            11111111 11111111 11111111 11111011 反码
            10000000 00000000 00000000 00000100 原码
            最高位的1表示负数  -4
         */

        System.out.println(13 >>> 2);
        /*
        对于正数来说，>>>与>>相同
        快速计算方式：右移几位相当于除以2的几次方
        13 / 2的2次 = 13 / 4 = 3.xxxx 向下取整的过程 = 3

        13：   00000000 00000000 00000000 00001101
        13>>>2： 00000000 00000000 00000000 00000011
         */
        System.out.println(-13 >>> 2);
        /*
        对于负数来说，>>> 与 >>不相同的    >>>是无符号右移，意思是不看原来的符号位
        -13的二进制补码：11111111 11111111 11111111 11110011
        -13>>>2        00111111 11111111 11111111 11111100
        最高位是0，是正数

         */

        System.out.println(5<<29);//变为负数，最高位原来是0，现在为1
        System.out.println(5<<34);//20  当移位的位数超过当前类型的总位数，会处理，直到移位的位数在总位数范围内
        //34 - 32 = 2
        System.out.println(5<<70);
        //70 % 32 = 6
    }
}
